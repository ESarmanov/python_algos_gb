"""
Задание 5.**

Приведен наивный алгоритм нахождения i-го по счёту
простого числа (через перебор делителей).

Попробуйте решить эту же задачу,
применив алгоритм "Решето Эратосфена" (https://younglinux.info/algorithm/sieve)

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

Укажите формулу сложности О-нотация каждого алгоритма
и сделайте обоснование рез-ам
"""
from timeit import timeit


def simple(i): # O(N^2)
    """Без использования «Решета Эратосфена»"""
    count = 1
    n = 2
    while count <= i:
        t = 1
        is_simple = True
        while t <= n:
            if n % t == 0 and t != 1 and t != n:
                is_simple = False
                break
            t += 1
        if is_simple:
            if count == i:
                break
            count += 1
        n += 1
    return n


i = int(input('Введите порядковый номер искомого простого числа: '))
print(simple(i))


#######################################################################
def eratossimple(num): # O(N^2)
    n = num * num
    # список заполняется значениями от 0 до n
    a = []
    for k in range(n + 1):
        a.append(k)
    # Вторым элементом является единица,
    # которую не считают простым числом
    # забиваем ее нулем.
    a[1] = 0
    # начинаем с 3-го элемента
    k = 2
    while k <= n:
        # Если значение ячейки до этого
        # не было обнулено,
        # в этой ячейке содержится
        # простое число.
        if a[k] != 0:
            # первое кратное ему
            # будет в два раза больше
            j = k + k
            while j <= n:
                # это число составное,
                # поэтому заменяем его нулем
                a[j] = 0
                # переходим к следующему числу,
                # которое кратно i
                # (оно на i больше)
                j = j + k
        k += 1
    # Превращая список во множество,
    # избавляемся от всех нулей кроме одного.
    a = set(a)
    # удаляем ноль
    a.remove(0)
    b = list(a)
    b.sort()
    return b[num - 1]


simple_cnt = i
simple_el = eratossimple(simple_cnt)
print(f"{simple_cnt}-ое простое число будет {simple_el}")

print()

print("simple      : ",
      timeit('simple(i)', setup='from __main__ import simple, i', number=10000))

print("eratossimple: ",
      timeit('eratossimple(simple_cnt)', setup='from __main__ import eratossimple, simple_cnt', number=10000))

"""
Введите порядковый номер искомого простого числа: 100
541
100-ое простое число будет 541


simple      :  41.6058891
eratossimple:  67.8897171

Сложность обоих алгоритмов O(N^2)
Но при этом второй алгоритм - Решето Эратосфена - выполняется в 1.5 раза дольше. 
"""