"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в
виде функции.

Обязательно доработайте алгоритм (сделайте его умнее)!

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение
Обязательно сделайте замеры времени обеих реализаций
и обосновать дала ли оптимизация эффективность

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.

Сделайте выводы!!!
Опишите в чем была ваша доработка и помогла ли вам доработка??
"""
from random import randint
from timeit import timeit


def fill_lst_not_ord(max_size):
    for i in range(max_size):
        lst_not_ord.append(randint(-100, 100))
    return


def sort_bubble_mthd(v_lst):
    for i in range(len(v_lst) - 1):
        for j in range(len(v_lst) - 1):
            if v_lst[j] < v_lst[j + 1]:
                v_lst[j], v_lst[j + 1] = v_lst[j + 1], v_lst[j]
    return


def sort_bubble_mthd_fix(v_lst):
    n = len(v_lst) - 1
    ordered = True
    while ordered:
        ordered = False
        for i in range(0, n):
            if v_lst[i] < v_lst[i + 1]:
                v_lst[i], v_lst[i + 1] = v_lst[i + 1], v_lst[i]
                ordered = True
        n -= 1
    return


max_size = 99     # количество элемeнтов массива
lst_not_ord = []  # оргинальный не отсортированный список

fill_lst_not_ord(max_size)

lst_ord = lst_not_ord.copy()      # копия списка для обычной сортировки
lst_ord_fix = lst_not_ord.copy()  # копия списка для оптимизированной сортировки

# sort_bubble_mthd(lst_ord)           # сортировка обычным пузырьком
# sort_bubble_mthd_fix(lst_ord_fix)   # сортировка оптимизированным пузырьком

print("-------------------- замеры ------------------------------------------")
n_iter = 10000  # кол-во тестов timeit
print("Сортировка обычным методом         : ",
      timeit('sort_bubble_mthd(lst_ord)', setup='from __main__ import sort_bubble_mthd, lst_ord'
             , number=n_iter))
print("Сортировка оптимизированным методом: ",
      timeit('sort_bubble_mthd_fix(lst_ord_fix)', setup='from __main__ import sort_bubble_mthd_fix, lst_ord_fix',
             number=n_iter))
print("Повторная cортировка уже отсортированного списка оптимизированным методом: ",
      timeit('sort_bubble_mthd_fix(lst_ord_fix)', setup='from __main__ import sort_bubble_mthd_fix, lst_ord_fix',
             number=n_iter))

print("----------------------------------------------------------------------")
print("первоначальный список           : ", lst_not_ord)
print("остортированный обычным способом: ", lst_ord)
print("остортированный оптим.  способом: ", lst_ord_fix)

"""
для n=99
-------------------- замеры ------------------------------------------
Сортировка обычным методом         :  11.2793309
Сортировка оптимизированным методом:  0.10487199999999852
Повторная cортировка уже отсортированного списка оптимизированным методом:  0.11463660000000075
----------------------------------------------------------------------
первоначальный список           :  [-82, 67, -76, -16, -64, -8, 92, 24, -88, -74, -99, -65, -7, 13, -91, ...]
остортированный обычным способом:  [98, 95, 92, 89, 81, 76, 76, 76, 74, 74, 72, 67, 65, 64, 63, 62, 61, ...]
остортированный оптим.  способом:  [98, 95, 92, 89, 81, 76, 76, 76, 74, 74, 72, 67, 65, 64, 63, 62, 61, ...]

модернизация алгоритма включает 2 этапа:
- с каждым циклом ряд уменьшается, т.к на последнем месте уже будет нужный элемент.
  Работа прекратится когда за проход не будет ни одной сортировки, а значит все элементы уже на своих местах
- введен признак сортировки, если сортировки за очередной проход не было - то массив уже отсортирован и можно прекратить
  цикл;
Наиболее эффективен такой способ в местах, где сортировка уже почти проведена.
"""
